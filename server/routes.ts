import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { createProxyMiddleware } from "http-proxy-middleware";
import { unsign } from "cookie-signature";
import { randomUUID } from "crypto";
import multer from "multer";
import { storage } from "./storage";
import { pool } from "./db";
import { SESSION_SECRET } from "./index";
import fs from "fs";
import path from "path";

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(process.cwd(), "uploads");
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// File storage configuration - save to disk instead of memory
const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const fileId = randomUUID();
    const ext = path.extname(file.originalname);
    cb(null, `${fileId}${ext}`);
  }
});

const upload = multer({ storage: fileStorage });
import { ObjectStorageService, ObjectNotFoundError } from "./objectStorage";
import { ObjectPermission } from "./objectAcl";
import {
  insertTournamentSchema,
  insertTeamSchema,
  insertMatchSchema,
  insertChatMessageSchema,
  insertRegistrationConfigSchema,
  insertRegistrationStepSchema,
  insertRegistrationFieldSchema,
  insertRegistrationSchema,
  insertRegistrationResponseSchema,
  insertServerSchema,
  insertChannelSchema,
  insertChannelCategorySchema,
  insertServerRoleSchema,
  insertServerBanSchema,
  insertServerInviteSchema,
  insertChannelMessageSchema,
  insertMessageThreadSchema,
  insertThreadMessageSchema,
  insertPosterTemplateSchema,
  insertPosterTemplateTagSchema,
  insertUserSchema,
  insertAchievementSchema,
  insertTeamProfileSchema,
  insertTeamMemberSchema,
  insertServerMemberSchema,
} from "@shared/schema";
import { z } from "zod";
import {
  generateRoundRobinBracket,
  generateSingleEliminationBracket,
  generateSwissSystemRound,
} from "./bracket-generator";

export async function registerRoutes(app: Express): Promise<Server> {
  app.use('/expo-app', createProxyMiddleware({
    target: 'http://127.0.0.1:8081',
    changeOrigin: true,
    ws: true,
    pathRewrite: {
      '^/expo-app': ''
    }
  }));
  const httpServer = createServer(app);
  const wss = new WebSocketServer({ 
    noServer: true
  });

  const matchConnections = new Map<string, Set<WebSocket>>();
  const channelConnections = new Map<string, Set<WebSocket>>();
  const wsUserMap = new Map<WebSocket, { userId: string; username: string }>();

  // Parse session from cookie and verify authentication
  const getSessionUserId = async (request: any): Promise<{ userId: string; username: string } | null> => {
    try {
      const cookies = request.headers.cookie || '';
      const sessionCookieMatch = cookies.match(/connect\.sid=([^;]+)/);
      
      if (!sessionCookieMatch) {
        return null;
      }

      // Decode the session ID (it's URL encoded with s: prefix)
      const sessionId = decodeURIComponent(sessionCookieMatch[1]);
      
      // Verify cookie signature using the shared session secret
      const unsigned = unsign(sessionId, SESSION_SECRET);
      
      if (!unsigned) {
        // Signature verification failed - cookie was tampered with
        return null;
      }

      // Query session from database using verified sid
      const result = await pool.query('SELECT sess FROM session WHERE sid = $1', [unsigned]);
      
      if (result.rows.length === 0 || !result.rows[0].sess?.userId) {
        return null;
      }

      const userId = result.rows[0].sess.userId;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return null;
      }

      return {
        userId: user.id,
        username: user.username || user.displayName || 'Unknown',
      };
    } catch (error) {
      console.error('Error parsing session:', error);
      return null;
    }
  };

  httpServer.on('upgrade', async (request, socket, head) => {
    const pathname = new URL(request.url || "", `http://${request.headers.host}`).pathname;
    
    if (pathname === '/ws/chat' || pathname === '/ws/channel') {
      // Verify authentication before upgrading
      const userInfo = await getSessionUserId(request);
      
      if (!userInfo) {
        socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n');
        socket.destroy();
        return;
      }

      wss.handleUpgrade(request, socket, head, (ws) => {
        wsUserMap.set(ws, userInfo);
        wss.emit('connection', ws, request);
      });
    }
  });

  wss.on("connection", (ws, req) => {
    const url = new URL(req.url || "", `http://${req.headers.host}`);
    const matchId = url.searchParams.get("matchId");
    const channelId = url.searchParams.get("channelId");
    const userInfo = wsUserMap.get(ws);

    if (!userInfo) {
      ws.close(1008, 'Unauthorized');
      return;
    }

    // Handle channel connections
    if (channelId) {
      if (!channelConnections.has(channelId)) {
        channelConnections.set(channelId, new Set());
      }
      channelConnections.get(channelId)!.add(ws);

      ws.on("message", async (data) => {
        try {
          const messageData = JSON.parse(data.toString());
          
          // Use authenticated user info from session, not client data
          const validatedData = insertChannelMessageSchema.parse({
            channelId: channelId,
            userId: userInfo.userId,
            username: userInfo.username,
            message: messageData.message,
            imageUrl: messageData.imageUrl || null,
            replyToId: messageData.replyToId || null,
          });

          // Create channel message with validated data
          const savedMessage = await storage.createChannelMessage(validatedData);

          // Broadcast to all connections in this channel
          const broadcastPayload = {
            type: "new_message",
            message: savedMessage,
          };
          broadcastToChannel(channelId, broadcastPayload);
        } catch (error: any) {
          console.error("Error handling channel WebSocket message:", error);
          ws.send(JSON.stringify({ error: "Failed to process message", details: error.message }));
        }
      });

      ws.on("close", () => {
        channelConnections.get(channelId)?.delete(ws);
        wsUserMap.delete(ws);
        if (channelConnections.get(channelId)?.size === 0) {
          channelConnections.delete(channelId);
        }
      });
    }
    // Handle match connections (existing functionality)
    else if (matchId) {
      if (!matchConnections.has(matchId)) {
        matchConnections.set(matchId, new Set());
      }
      matchConnections.get(matchId)!.add(ws);

      // Handle incoming messages
      ws.on("message", async (data) => {
        try {
          const messageData = JSON.parse(data.toString());
          
          // Get userId from authenticated user info
          const userInfo = wsUserMap.get(ws);
          if (!userInfo) {
            ws.send(JSON.stringify({ error: "Unauthorized" }));
            return;
          }
          
          // Validate using schema and ensure matchId from URL is used
          const validatedData = insertChatMessageSchema.parse({
            matchId: matchId, // Use matchId from connection URL for security
            teamId: messageData.teamId || null, // Optional field
            userId: userInfo.userId, // Include userId from authenticated connection
            message: messageData.message,
            imageUrl: messageData.imageUrl || null, // Optional field
          });

          // Save message to storage
          const savedMessage = await storage.createChatMessage(validatedData);
          console.log(`[WS-SAVE] Input validatedData:`, { userId: validatedData.userId, matchId: validatedData.matchId });
          console.log(`[WS-SAVE] Saved message from DB:`, { id: savedMessage.id, userId: savedMessage.userId, matchId: savedMessage.matchId });

          // Enrich message with username and avatarUrl before broadcasting
          const enrichedMessage: any = {
            id: savedMessage.id,
            matchId: savedMessage.matchId,
            teamId: savedMessage.teamId || null,
            userId: savedMessage.userId || null,
            message: savedMessage.message || null,
            imageUrl: savedMessage.imageUrl || null,
            isSystem: savedMessage.isSystem || 0,
            createdAt: savedMessage.createdAt,
          };
          
          console.log(`[WS-ENRICH] Message saved with userId: ${savedMessage.userId}`);
          
          if (savedMessage.userId) {
            const sender = await storage.getUser(savedMessage.userId);
            enrichedMessage.username = sender?.username || "Unknown";
            enrichedMessage.avatarUrl = sender?.avatarUrl || null;
            console.log(`[WS-ENRICH] User lookup: userId=${savedMessage.userId} -> username=${enrichedMessage.username}, avatarUrl=${enrichedMessage.avatarUrl}`);
          } else {
            enrichedMessage.username = "Unknown";
            enrichedMessage.avatarUrl = null;
            console.log(`[WS-ENRICH] No userId in savedMessage - will broadcast: ${JSON.stringify(enrichedMessage)}`);
          }

          console.log(`[WS-BROADCAST] Broadcasting message with username: ${enrichedMessage.username}`);

          // Broadcast enriched message to all connections in this match
          const broadcastPayload = {
            type: "new_message",
            message: enrichedMessage,
          };
          broadcastToMatch(matchId, broadcastPayload);
        } catch (error: any) {
          console.error("Error handling WebSocket message:", error);
          console.error("Error details:", error.message);
          ws.send(JSON.stringify({ error: "Failed to process message", details: error.message }));
        }
      });

      ws.on("close", () => {
        matchConnections.get(matchId)?.delete(ws);
        if (matchConnections.get(matchId)?.size === 0) {
          matchConnections.delete(matchId);
        }
      });
    }
  });

  const broadcastToMatch = (matchId: string, data: any) => {
    const connections = matchConnections.get(matchId);
    if (connections) {
      const message = JSON.stringify(data);
      connections.forEach((ws) => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(message);
        }
      });
    }
  };

  const broadcastToChannel = (channelId: string, data: any) => {
    const connections = channelConnections.get(channelId);
    if (connections) {
      const message = JSON.stringify(data);
      connections.forEach((ws) => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(message);
        }
      });
    }
  };

  // Authentication middleware
  const requireAuth = (req: any, res: any, next: any) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    next();
  };

  // Authentication routes
  app.post("/api/auth/register", async (req, res) => {
    try {
      const registerSchema = z.object({
        fullName: z.string().min(2),
        email: z.string().email(),
        password: z.string().min(6),
      });
      const validatedData = registerSchema.parse(req.body);

      // Check if user with email already exists
      const existingUser = await storage.getUserByEmail(validatedData.email);
      if (existingUser) {
        return res.status(400).json({ error: "Email already registered" });
      }

      // Hash password
      const bcrypt = await import('bcrypt');
      const hashedPassword = await bcrypt.hash(validatedData.password, 10);

      // Create user with hashed password
      const user = await storage.createUser({
        username: validatedData.fullName.toLowerCase().replace(/\s+/g, ''),
        email: validatedData.email,
        passwordHash: hashedPassword,
        displayName: validatedData.fullName,
        bio: null,
        avatarUrl: null,
        language: 'en',
        isDisabled: 0,
      });

      // Automatically log in the user after registration
      req.session.userId = user.id;

      res.status(201).json({ 
        message: "Registration successful",
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          displayName: user.displayName,
        }
      });
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "Invalid input data" });
      }
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const loginSchema = z.object({
        email: z.string().email(),
        password: z.string(),
      });
      const validatedData = loginSchema.parse(req.body);

      // Find user by email
      const user = await storage.getUserByEmail(validatedData.email);

      if (!user) {
        return res.status(401).json({ error: "Invalid email or password" });
      }

      // Verify password
      const bcrypt = await import('bcrypt');
      if (!user.passwordHash) {
        return res.status(401).json({ error: "Invalid email or password" });
      }
      const passwordValid = await bcrypt.compare(validatedData.password, user.passwordHash);

      if (!passwordValid) {
        return res.status(401).json({ error: "Invalid email or password" });
      }

      // If account is disabled, automatically reactivate it on successful login
      if (user.isDisabled === 1) {
        await storage.updateUser(user.id, { isDisabled: 0 });
      }

      // Create session
      req.session.userId = user.id;

      res.json({
        message: "Login successful",
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          displayName: user.displayName,
          avatarUrl: user.avatarUrl,
          bio: user.bio,
          level: user.level,
        },
        token: "session-based-auth",
      });
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "Invalid input data" });
      }
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ error: "Failed to logout" });
      }
      res.clearCookie('connect.sid');
      res.json({ message: "Logout successful" });
    });
  });

  app.get("/api/auth/me", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }

      const user = await storage.getUser(req.session.userId);
      if (!user) {
        req.session.destroy(() => {});
        return res.status(404).json({ error: "User not found" });
      }

      res.json({
        id: user.id,
        username: user.username,
        email: user.email,
        displayName: user.displayName,
        avatarUrl: user.avatarUrl,
        bio: user.bio,
        level: user.level,
        language: user.language,
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Tournament routes
  app.get("/api/tournaments", async (req, res) => {
    try {
      const tournaments = await storage.getAllTournaments();
      res.json(tournaments);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/tournaments/:id", async (req, res) => {
    try {
      const tournament = await storage.getTournament(req.params.id);
      if (!tournament) {
        return res.status(404).json({ error: "Tournament not found" });
      }
      res.json(tournament);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/tournaments/:id", async (req, res) => {
    try {
      const tournament = await storage.updateTournament(req.params.id, req.body);
      if (!tournament) {
        return res.status(404).json({ error: "Tournament not found" });
      }
      res.json(tournament);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/tournaments", async (req, res) => {
    try {
      console.log('[DEBUG] Tournament creation request body:', JSON.stringify(req.body, null, 2));
      const validatedData = insertTournamentSchema.parse(req.body);
      
      // Extract registration config and team names (don't save these to tournament table)
      // Keep serverId - it needs to be saved!
      const { teamNames, registrationConfig, ...tournamentData } = validatedData;
      
      const tournament = await storage.createTournament(tournamentData);

      if (teamNames && teamNames.length > 0) {
        const createdTeams = await Promise.all(
          teamNames.map((name) =>
            storage.createTeam({
              name,
              tournamentId: tournament.id,
            })
          )
        );

        let matches;
        if (tournament.format === "round_robin") {
          matches = generateRoundRobinBracket(tournament.id, createdTeams).matches;
        } else if (tournament.format === "single_elimination") {
          matches = generateSingleEliminationBracket(tournament.id, createdTeams).matches;
        } else if (tournament.format === "swiss") {
          matches = generateSwissSystemRound(tournament.id, createdTeams, 1, []).matches;
        }

        if (matches) {
          await Promise.all(matches.map((match) => storage.createMatch(match)));
        }
      }

      console.log('[REGISTRATION] Config received:', registrationConfig ? `Yes - ${registrationConfig.steps?.length || 0} steps` : 'No');
      console.log('[REGISTRATION] Full config:', JSON.stringify(registrationConfig, null, 2));
      
      if (registrationConfig) {
        let createdConfigId: string | null = null;
        const createdStepIds: string[] = [];
        
        try {
          const configData = {
            tournamentId: tournament.id,
            requiresPayment: registrationConfig.requiresPayment,
            entryFee: registrationConfig.entryFee,
            paymentUrl: registrationConfig.paymentUrl,
            paymentInstructions: registrationConfig.paymentInstructions
          };
          
          const validatedConfig = insertRegistrationConfigSchema.parse(configData);
          const createdConfig = await storage.createRegistrationConfig(validatedConfig);
          createdConfigId = createdConfig.id;
          console.log('[REGISTRATION] Config created with ID:', createdConfigId);

          console.log('[REGISTRATION] Processing', registrationConfig.steps?.length || 0, 'steps');
          for (const step of registrationConfig.steps) {
            console.log('[REGISTRATION] Processing step:', step.stepTitle, 'with', step.fields?.length || 0, 'fields');
            const stepData = {
              configId: createdConfig.id,
              stepNumber: step.stepNumber,
              stepTitle: step.stepTitle,
              stepDescription: step.stepDescription
            };
            const validatedStep = insertRegistrationStepSchema.parse(stepData);
            const createdStep = await storage.createRegistrationStep(validatedStep);
            createdStepIds.push(createdStep.id);
            console.log('[REGISTRATION] Step created:', createdStep.id);

            for (const field of step.fields) {
              console.log('[REGISTRATION] Creating field:', field.fieldLabel);
              const fieldData = {
                stepId: createdStep.id,
                fieldType: field.fieldType,
                fieldLabel: field.fieldLabel,
                fieldPlaceholder: field.fieldPlaceholder,
                isRequired: field.isRequired,
                dropdownOptions: field.dropdownOptions,
                displayOrder: field.displayOrder
              };
              const validatedField = insertRegistrationFieldSchema.parse(fieldData);
              await storage.createRegistrationField(validatedField);
              console.log('[REGISTRATION] Field created:', field.fieldLabel);
            }
          }
          console.log('[REGISTRATION] All fields saved successfully');
        } catch (regError: any) {
          console.log('[REGISTRATION] ERROR:', regError.message);
          if (createdConfigId) {
            await storage.deleteRegistrationConfig(createdConfigId);
          }
          throw new Error(`Failed to create registration config: ${regError.message}`);
        }
      }

      res.status(201).json(tournament);
    } catch (error: any) {
      console.error('[DEBUG] Tournament creation error:', error);
      if (error.errors) {
        console.error('[DEBUG] Zod validation errors:', JSON.stringify(error.errors, null, 2));
      }
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/tournaments/:id/registration/config", async (req, res) => {
    try {
      const tournamentId = req.params.id;
      console.log('[REGISTRATION-GET] Querying config for tournament:', tournamentId);
      
      const config = await storage.getRegistrationConfigByTournament(tournamentId);
      console.log('[REGISTRATION-GET] Config found:', config ? `Yes - ID: ${config.id}` : 'No');
      
      // If no config exists, return null - do NOT auto-create defaults
      if (!config) {
        console.log('[REGISTRATION-GET] Returning null - no config for this tournament');
        return res.json(null);
      }

      console.log('[REGISTRATION-GET] Fetching steps for config:', config.id);
      const steps = await storage.getStepsByConfig(config.id);
      console.log('[REGISTRATION-GET] Steps found:', steps.length);
      
      const stepsWithFields = await Promise.all(
        steps.map(async (step) => {
          const fields = await storage.getFieldsByStep(step.id);
          console.log('[REGISTRATION-GET] Step', step.id, 'has', fields.length, 'fields');
          return {
            ...step,
            fields: fields.sort((a, b) => a.displayOrder - b.displayOrder)
          };
        })
      );

      res.json({
        ...config,
        steps: stepsWithFields.sort((a, b) => a.stepNumber - b.stepNumber)
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.put("/api/tournaments/:id/registration/config", async (req, res) => {
    try {
      const { id } = req.params;
      const registrationConfig = req.body;

      let config = await storage.getRegistrationConfigByTournament(id);
      
      if (!config) {
        const configData = {
          tournamentId: id,
          requiresPayment: registrationConfig.requiresPayment,
          entryFee: registrationConfig.entryFee,
          paymentUrl: registrationConfig.paymentUrl,
          paymentInstructions: registrationConfig.paymentInstructions
        };
        const validatedConfig = insertRegistrationConfigSchema.parse(configData);
        config = await storage.createRegistrationConfig(validatedConfig);
      } else {
        await storage.updateRegistrationConfig(config.id, {
          requiresPayment: registrationConfig.requiresPayment,
          entryFee: registrationConfig.entryFee,
          paymentUrl: registrationConfig.paymentUrl,
          paymentInstructions: registrationConfig.paymentInstructions
        });
      }

      // Delete all existing steps and their fields for this config
      const existingSteps = await storage.getStepsByConfig(config.id);
      for (const step of existingSteps) {
        const fields = await storage.getFieldsByStep(step.id);
        for (const field of fields) {
          await storage.deleteRegistrationField(field.id);
        }
        await storage.deleteRegistrationStep(step.id);
      }

      // Create all new steps from the organizer's config
      for (const step of registrationConfig.steps) {
        const stepData = {
          configId: config.id,
          stepNumber: step.stepNumber,
          stepTitle: step.stepTitle,
          stepDescription: step.stepDescription
        };
        const validatedStep = insertRegistrationStepSchema.parse(stepData);
        const createdStep = await storage.createRegistrationStep(validatedStep);

        // Create all fields for this step
        for (const field of step.fields) {
          const fieldData = {
            stepId: createdStep.id,
            fieldType: field.fieldType,
            fieldLabel: field.fieldLabel,
            fieldPlaceholder: field.fieldPlaceholder,
            isRequired: field.isRequired,
            dropdownOptions: field.dropdownOptions,
            displayOrder: field.displayOrder
          };
          const validatedField = insertRegistrationFieldSchema.parse(fieldData);
          await storage.createRegistrationField(validatedField);
        }
      }

      const steps = await storage.getStepsByConfig(config.id);
      const stepsWithFields = await Promise.all(
        steps.map(async (step) => {
          const fields = await storage.getFieldsByStep(step.id);
          return {
            ...step,
            fields: fields.sort((a, b) => a.displayOrder - b.displayOrder)
          };
        })
      );

      res.json({
        ...config,
        steps: stepsWithFields.sort((a, b) => a.stepNumber - b.stepNumber)
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Team routes
  app.get("/api/tournaments/:tournamentId/teams", async (req, res) => {
    try {
      const teams = await storage.getTeamsByTournament(req.params.tournamentId);
      res.json(teams);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/teams", async (req, res) => {
    try {
      const validatedData = insertTeamSchema.parse(req.body);
      const team = await storage.createTeam(validatedData);
      res.status(201).json(team);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.patch("/api/teams/:id", async (req, res) => {
    try {
      const team = await storage.getTeam(req.params.id);
      if (!team) {
        return res.status(404).json({ error: "Team not found" });
      }
      const updatedTeam = await storage.updateTeam(req.params.id, req.body);
      res.json(updatedTeam);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  // Match routes
  app.get("/api/tournaments/:tournamentId/matches", async (req, res) => {
    try {
      const matches = await storage.getMatchesByTournament(req.params.tournamentId);
      res.json(matches);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/matches/:id", async (req, res) => {
    try {
      const match = await storage.getMatch(req.params.id);
      if (!match) {
        return res.status(404).json({ error: "Match not found" });
      }
      
      // Fetch team records - they have the authoritative team names
      const team1 = match.team1Id ? await storage.getTeam(match.team1Id) : null;
      const team2 = match.team2Id ? await storage.getTeam(match.team2Id) : null;
      
      res.json({
        ...match,
        team1Name: team1?.name || "Team 1",
        team2Name: team2?.name || "Team 2",
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/matches/:id", async (req, res) => {
    try {
      const currentMatch = await storage.getMatch(req.params.id);
      if (!currentMatch) {
        return res.status(404).json({ error: "Match not found" });
      }

      if (req.body.winnerId) {
        const validTeams = [currentMatch.team1Id, currentMatch.team2Id].filter(Boolean);
        if (!validTeams.includes(req.body.winnerId)) {
          return res.status(400).json({ error: "Winner must be one of the match participants" });
        }
      }

      const wasAlreadyCompleted = currentMatch.status === "completed";
      
      const match = await storage.updateMatch(req.params.id, req.body);
      if (!match) {
        return res.status(404).json({ error: "Match not found after update" });
      }

      if (!wasAlreadyCompleted && req.body.winnerId && req.body.team1Score !== undefined && req.body.team2Score !== undefined) {
        const teams = [match.team1Id, match.team2Id].filter(Boolean) as string[];
        const loserId = teams.find((id) => id !== req.body.winnerId);

        if (req.body.winnerId) {
          const winnerTeam = await storage.getTeam(req.body.winnerId);
          if (winnerTeam) {
            await storage.updateTeam(req.body.winnerId, {
              wins: (winnerTeam.wins ?? 0) + 1,
              points: (winnerTeam.points ?? 0) + 3,
            });
          }
        }

        if (loserId) {
          const loserTeam = await storage.getTeam(loserId);
          if (loserTeam) {
            await storage.updateTeam(loserId, {
              losses: (loserTeam.losses ?? 0) + 1,
            });
          }
        }

        const tournament = await storage.getTournament(match.tournamentId);
        
        if (tournament && tournament.format === "single_elimination" && req.body.winnerId) {
          const allMatches = await storage.getMatchesByTournament(tournament.id);
          const currentRoundMatches = allMatches.filter((m) => m.round === match.round);
          const matchIndex = currentRoundMatches.findIndex((m) => m.id === match.id);
          
          if (matchIndex !== -1) {
            const nextRoundMatchIndex = Math.floor(matchIndex / 2);
            const nextRoundMatches = allMatches.filter((m) => m.round === match.round + 1);
            const nextMatch = nextRoundMatches[nextRoundMatchIndex];
            
            if (nextMatch) {
              const isFirstSlot = matchIndex % 2 === 0;
              await storage.updateMatch(nextMatch.id, {
                [isFirstSlot ? "team1Id" : "team2Id"]: req.body.winnerId,
              });
            }
          }
        }
        
        if (tournament && tournament.format === "swiss") {
          const allMatches = await storage.getMatchesByTournament(tournament.id);
          const currentRoundMatches = allMatches.filter((m) => m.round === tournament.currentRound);
          const allCompleted = currentRoundMatches.every((m) => m.status === "completed");

          const currentRound = tournament.currentRound ?? 1;
          if (allCompleted && currentRound < (tournament.swissRounds ?? 5)) {
            const teams = await storage.getTeamsByTournament(tournament.id);
            const nextRound = currentRound + 1;
            const newMatches = generateSwissSystemRound(tournament.id, teams, nextRound, allMatches).matches;

            await Promise.all(newMatches.map((m) => storage.createMatch(m)));
            await storage.updateTournament(tournament.id, { currentRound: nextRound });
          }
        }
      }

      res.json(match);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Select winner endpoint (marks match complete and removes loser)
  app.post("/api/matches/:matchId/winner", async (req, res) => {
    try {
      const { winnerId } = req.body;
      const match = await storage.getMatch(req.params.matchId);

      if (!match) {
        return res.status(404).json({ error: "Match not found" });
      }

      if (!winnerId) {
        return res.status(400).json({ error: "Winner ID is required" });
      }

      const validTeams = [match.team1Id, match.team2Id].filter(Boolean);
      if (!validTeams.includes(winnerId)) {
        return res.status(400).json({ error: "Winner must be one of the match participants" });
      }

      // Update match with winner and complete status
      const updatedMatch = await storage.updateMatch(req.params.matchId, {
        winnerId,
        status: "completed",
      });

      // Update winner stats
      const winnerTeam = await storage.getTeam(winnerId);
      if (winnerTeam) {
        await storage.updateTeam(winnerId, {
          wins: (winnerTeam.wins ?? 0) + 1,
          points: (winnerTeam.points ?? 0) + 3,
        });
      }

      // Record loss for loser
      const loserId = validTeams.find((id) => id !== winnerId);
      if (loserId) {
        const loserTeam = await storage.getTeam(loserId);
        if (loserTeam) {
          await storage.updateTeam(loserId, {
            losses: (loserTeam.losses ?? 0) + 1,
          });
        }
      }

      res.json(updatedMatch);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Archive/close message thread endpoint
  app.delete("/api/message-threads/:threadId", async (req, res) => {
    try {
      const thread = await storage.getMessageThread(req.params.threadId);
      if (!thread) {
        return res.status(404).json({ error: "Thread not found" });
      }

      // Delete all messages in the thread
      const messages = await storage.getThreadMessages(req.params.threadId);
      await Promise.all(messages.map((msg) => storage.deleteThreadMessage(msg.id)));

      // Delete the thread itself
      await storage.deleteMessageThread(req.params.threadId);

      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Create custom match endpoint
  app.post("/api/tournaments/:tournamentId/matches/custom", async (req, res) => {
    try {
      const { team1Id, team2Id } = req.body;
      console.log("[MATCH-CREATION] Endpoint called with team1Id:", team1Id, "team2Id:", team2Id);
      const tournament = await storage.getTournament(req.params.tournamentId);

      if (!tournament) {
        return res.status(404).json({ error: "Tournament not found" });
      }

      const team1 = await storage.getTeam(team1Id);
      const team2 = await storage.getTeam(team2Id);

      if (!team1 || !team2) {
        return res.status(404).json({ error: "One or both teams not found" });
      }

      if (team1.isRemoved || team2.isRemoved) {
        return res.status(400).json({ error: "Cannot create match with eliminated teams" });
      }

      const allMatches = await storage.getMatchesByTournament(tournament.id);
      console.log("[MATCH-CREATION] Total existing matches in tournament:", allMatches.length);
      
      // Check if a match already exists between these two teams
      const existingMatch = allMatches.find(m => 
        (m.team1Id === team1Id && m.team2Id === team2Id) || 
        (m.team1Id === team2Id && m.team2Id === team1Id)
      );
      console.log("[MATCH-CREATION] Existing match found:", !!existingMatch);

      let matchToReturn;
      const matchMessage = `Match: ${team1.name} vs ${team2.name}`;
      const threadMessage = `Match updated in ${tournament.name}. Chat with your opponent here!`;

      if (existingMatch) {
        // Update existing match and its message thread
        matchToReturn = existingMatch;
        
        // Find and update the message thread for this match
        const allThreads = await storage.getAllMessageThreads();
        const matchThread = allThreads.find(t => t.matchId === existingMatch.id);
        
        if (matchThread) {
          await storage.updateMessageThread(matchThread.id, {
            lastMessage: threadMessage,
            lastMessageTime: new Date(),
            unreadCount: (matchThread.unreadCount || 0) + 1,
          });
        }
      } else {
        // Create new match and message thread
        const maxRound = Math.max(...allMatches.map(m => m.round || 1), 0);
        
        matchToReturn = await storage.createMatch({
          tournamentId: tournament.id,
          team1Id,
          team2Id,
          round: maxRound + 1,
          status: "pending",
        });

        console.log("[MATCH-CREATION] New match created:", matchToReturn.id);
        
        // Create ONE shared message thread per match (not per participant)
        const sharedThreadData = {
          userId: undefined, // No userId - this is a shared thread
          matchId: matchToReturn.id,
          participantName: matchMessage,
          lastMessage: threadMessage,
          lastMessageTime: new Date(),
          unreadCount: 0,
        };
        
        try {
          await storage.createMessageThread(sharedThreadData);
          console.log("[MATCH-CREATION] Shared thread created for matchId:", matchToReturn.id);
        } catch (error) {
          console.error("[MATCH-CREATION] Failed to create shared thread for matchId:", matchToReturn.id, error);
        }
      }

      res.status(201).json(matchToReturn);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Match details endpoint (for 1v1 tournament match screen)
  app.get("/api/tournaments/:tournamentId/matches/:matchId/details", async (req, res) => {
    try {
      const match = await storage.getMatch(req.params.matchId);
      if (!match) {
        return res.status(404).json({ error: "Match not found" });
      }

      const tournament = await storage.getTournament(req.params.tournamentId);
      if (!tournament) {
        return res.status(404).json({ error: "Tournament not found" });
      }

      const team1 = match.team1Id ? await storage.getTeam(match.team1Id) : null;
      const team2 = match.team2Id ? await storage.getTeam(match.team2Id) : null;

      res.json({
        match,
        tournament,
        team1,
        team2,
        team1Players: [],
        team2Players: [],
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Chat routes for message inbox match participants (OLD SYSTEM - KEEP FOR MESSAGE INBOX COMPATIBILITY)
  app.get("/api/matches/:matchId/messages", async (req, res) => {
    try {
      const matchId = req.params.matchId;
      console.log(`[DASHBOARD-MATCH-CHAT-GET] Fetching messages for match: ${matchId}`);
      const messages = await storage.getChatMessagesByMatch(matchId);
      console.log(`[DASHBOARD-MATCH-CHAT-GET] Found ${messages.length} raw messages`);
      
      // Enrich messages with sender username, avatar, and displayName from users table
      const enrichedMessages = await Promise.all(
        messages.map(async (msg: any) => {
          let username = "Unknown";
          let avatarUrl: string | undefined;
          let displayName: string | undefined;
          
          console.log(`[DASHBOARD-MATCH-CHAT-ENRICH] Processing message ${msg.id}, userId: ${msg.userId}`);
          
          if (msg.userId) {
            try {
              const sender = await storage.getUser(msg.userId);
              if (sender) {
                username = sender.username || "Unknown";
                avatarUrl = sender.avatarUrl ?? undefined;
                displayName = sender.displayName?.trim() || sender.username || "Unknown";
                console.log(`[DASHBOARD-MATCH-CHAT-ENRICH] Message ${msg.id}: username=${username}, displayName=${displayName}, avatarUrl=${avatarUrl}`);
              } else {
                console.log(`[DASHBOARD-MATCH-CHAT-ENRICH] Message ${msg.id}: sender not found`);
              }
            } catch (e) {
              console.error("[DASHBOARD-MATCH-CHAT-ENRICH] Failed to get user:", msg.userId, e);
            }
          } else {
            console.log(`[DASHBOARD-MATCH-CHAT-ENRICH] Message ${msg.id}: no userId`);
          }
          
          const enriched: any = {
            id: msg.id,
            matchId: msg.matchId,
            teamId: msg.teamId || null,
            userId: msg.userId || null,
            message: msg.message || null,
            imageUrl: msg.imageUrl || null,
            isSystem: msg.isSystem,
            createdAt: msg.createdAt,
            username,
            displayName,
          };
          
          // Only include avatarUrl if it's actually defined
          if (avatarUrl) {
            enriched.avatarUrl = avatarUrl;
          }
          
          console.log(`[DASHBOARD-MATCH-CHAT-ENRICH] Final enriched message:`, JSON.stringify(enriched));
          return enriched;
        })
      );
      
      res.removeHeader("ETag");
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate, private, max-age=0");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      res.setHeader("X-Timestamp", Date.now().toString());
      console.log(`[DASHBOARD-MATCH-CHAT-GET] Returning ${enrichedMessages.length} enriched messages`);
      res.json(enrichedMessages);
    } catch (error: any) {
      console.error("[DASHBOARD-MATCH-CHAT-GET] Error:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/matches/:matchId/messages", async (req, res) => {
    try {
      const matchId = req.params.matchId;
      console.log(`[DASHBOARD-MATCH-CHAT-POST] Received message for match: ${matchId}`, JSON.stringify(req.body));
      
      const validatedData = insertChatMessageSchema.parse({
        ...req.body,
        matchId: matchId,
      });
      console.log(`[DASHBOARD-MATCH-CHAT-POST] Validated data:`, JSON.stringify(validatedData));
      
      const message = await storage.createChatMessage(validatedData);
      console.log(`[DASHBOARD-MATCH-CHAT-POST] Created message:`, JSON.stringify(message));

      // Enrich message with username, avatar, and displayName before returning
      const enrichedMessage: any = {
        id: message.id,
        matchId: message.matchId,
        teamId: message.teamId,
        userId: message.userId,
        message: message.message,
        imageUrl: message.imageUrl,
        isSystem: message.isSystem,
        createdAt: message.createdAt,
      };
      
      if (message.userId) {
        console.log(`[DASHBOARD-MATCH-CHAT-POST] Fetching user data for userId: ${message.userId}`);
        const sender = await storage.getUser(message.userId);
        if (sender) {
          enrichedMessage.username = sender.username || "Unknown";
          enrichedMessage.displayName = sender.displayName?.trim() || sender.username || "Unknown";
          if (sender.avatarUrl) {
            enrichedMessage.avatarUrl = sender.avatarUrl;
          }
          console.log(`[DASHBOARD-MATCH-CHAT-POST] Enriched: username=${enrichedMessage.username}, displayName=${enrichedMessage.displayName}, avatarUrl=${enrichedMessage.avatarUrl}`);
        } else {
          enrichedMessage.username = "Unknown";
          console.log(`[DASHBOARD-MATCH-CHAT-POST] Sender not found for userId: ${message.userId}`);
        }
      } else {
        enrichedMessage.username = "Unknown";
        console.log(`[DASHBOARD-MATCH-CHAT-POST] No userId in message`);
      }

      console.log(`[DASHBOARD-MATCH-CHAT-POST] Final enriched message:`, JSON.stringify(enrichedMessage));
      res.status(201).json(enrichedMessage);
    } catch (error: any) {
      console.error("[DASHBOARD-MATCH-CHAT-POST] Error:", error);
      res.status(400).json({ error: error.message });
    }
  });

  // Registration Config routes
  app.post("/api/tournaments/:tournamentId/registration-config", async (req, res) => {
    try {
      const { steps, ...configData } = req.body;
      
      const config = await storage.createRegistrationConfig({
        ...configData,
        tournamentId: req.params.tournamentId,
      });

      if (steps && steps.length > 0) {
        for (const step of steps) {
          const { fields, ...stepData } = step;
          const createdStep = await storage.createRegistrationStep({
            ...stepData,
            configId: config.id,
          });

          if (fields && fields.length > 0) {
            await Promise.all(
              fields.map((field: any) =>
                storage.createRegistrationField({
                  ...field,
                  stepId: createdStep.id,
                })
              )
            );
          }
        }
      }

      res.status(201).json(config);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/tournaments/:tournamentId/registration-config", async (req, res) => {
    try {
      const config = await storage.getRegistrationConfigByTournament(req.params.tournamentId);
      if (!config) {
        return res.status(404).json({ error: "Registration config not found" });
      }

      const steps = await storage.getStepsByConfig(config.id);
      const stepsWithFields = await Promise.all(
        steps.map(async (step) => {
          const fields = await storage.getFieldsByStep(step.id);
          return { ...step, fields };
        })
      );

      res.json({ ...config, steps: stepsWithFields });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Registration submission routes
  app.post("/api/tournaments/:tournamentId/registrations", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "You must be logged in to register" });
      }

      const tournamentId = req.params.tournamentId;
      
      const tournament = await storage.getTournament(tournamentId);
      if (!tournament) {
        return res.status(404).json({ error: "Tournament not found" });
      }

      const { responses, paymentProofUrl, paymentTransactionId } = req.body;

      // Team name comes from the first response in the form
      let teamName: string | null = null;
      
      if (responses && typeof responses === 'object') {
        // Get the first value from responses (which is the team name from first step)
        const responseValues = Object.values(responses) as (string | undefined)[];
        if (responseValues.length > 0 && responseValues[0]) {
          teamName = String(responseValues[0]).trim();
        }
      }

      if (!teamName) {
        console.error("[REGISTRATION] Team name extraction failed. Responses:", responses);
        return res.status(400).json({ error: "Team name is required" });
      }

      // Get registration config for payment status
      const config = await storage.getRegistrationConfigByTournament(tournamentId);

      const existingTeams = await storage.getTeamsByTournament(tournamentId);
      const existingRegistrations = await storage.getRegistrationsByTournament(tournamentId);
      
      const pendingRegistrations = existingRegistrations.filter(
        r => r.status === "submitted"
      );
      
      const totalCapacityUsed = existingTeams.length + pendingRegistrations.length;
      // Only check capacity if totalTeams is positive (unlimited is -1)
      if (tournament.totalTeams > 0 && totalCapacityUsed >= tournament.totalTeams) {
        return res.status(409).json({ error: "Tournament is full" });
      }

      const teamNameLower = teamName.toLowerCase();
      const teamNameExistsInTeams = existingTeams.some(
        team => team.name.toLowerCase() === teamNameLower
      );
      const teamNameExistsInRegistrations = existingRegistrations.some(
        reg => (reg.status === "submitted" || reg.status === "approved") && 
               reg.teamName?.toLowerCase() === teamNameLower
      );
      
      if (teamNameExistsInTeams || teamNameExistsInRegistrations) {
        return res.status(409).json({ error: "Team name already exists in this tournament" });
      }
      
      let paymentStatus = "pending";
      let registrationStatus = "submitted";
      
      if (config && config.requiresPayment) {
        if (paymentProofUrl || paymentTransactionId) {
          paymentStatus = "submitted";
        }
      } else {
        paymentStatus = "verified";
        registrationStatus = "approved";
      }
      
      const registration = await storage.createRegistration({
        userId: req.session.userId,
        teamName,
        tournamentId,
        status: registrationStatus,
        paymentStatus,
        paymentProofUrl: paymentProofUrl || null,
        paymentTransactionId: paymentTransactionId || null,
      });

      let parsedResponses = responses;
      if (typeof responses === 'string') {
        try {
          parsedResponses = JSON.parse(responses);
        } catch (e) {
          console.error("Failed to parse responses JSON:", e);
        }
      }

      if (parsedResponses && typeof parsedResponses === 'object') {
        await Promise.all(
          Object.entries(parsedResponses).map(([fieldId, value]) =>
            storage.createRegistrationResponse({
              registrationId: registration.id,
              fieldId,
              responseValue: String(value),
            })
          )
        );
      }

      if (registrationStatus === "approved") {
        const team = await storage.createTeam({
          name: teamName,
          tournamentId: tournament.id,
        });
        // Add registering user as team member
        await storage.createTeamMember({
          teamId: team.id,
          userId: req.session.userId,
        });

        // Auto-generate fixtures when a team registers
        try {
          const allTeams = await storage.getTeamsByTournament(tournament.id);
          const existingMatches = await storage.getMatchesByTournament(tournament.id);
          
          // Only generate if no matches exist yet
          if (existingMatches.length === 0 && allTeams.length > 0) {
            let matches;
            if (tournament.format === "round_robin") {
              matches = generateRoundRobinBracket(tournament.id, allTeams).matches;
            } else if (tournament.format === "single_elimination") {
              matches = generateSingleEliminationBracket(tournament.id, allTeams).matches;
            } else if (tournament.format === "swiss") {
              matches = generateSwissSystemRound(tournament.id, allTeams, 1, []).matches;
            }

            if (matches && matches.length > 0) {
              // Create all matches
              await Promise.all(matches.map((match) => storage.createMatch(match)));
              
              // Create message threads for each match
              for (const match of matches) {
                const team1 = allTeams.find(t => t.id === match.team1Id);
                const team2 = allTeams.find(t => t.id === match.team2Id);
                
                // Skip bye matches
                if (!team1 || !team2) continue;
                
                const threadName = `${team1.name} vs ${team2.name}`;
                await storage.createMessageThread({
                  userId: tournament.organizerId || 'system',
                  participantName: threadName,
                  participantAvatar: null,
                  lastMessage: `Match created: ${threadName}`,
                  unreadCount: 0,
                });
              }
            }
          }
        } catch (error) {
          console.error("[FIXTURES] Error auto-generating fixtures:", error);
          // Don't fail registration if fixture generation fails
        }
      }

      res.status(201).json(registration);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/tournaments/:tournamentId/registrations", async (req, res) => {
    try {
      const registrations = await storage.getRegistrationsByTournament(req.params.tournamentId);
      
      // Join registrations with user data to return real usernames
      const registrationsWithUsers = await Promise.all(
        registrations.map(async (reg) => {
          const user = await storage.getUser(reg.userId);
          return {
            ...reg,
            userUsername: user?.username || user?.displayName || 'Unknown',
            userDisplayName: user?.displayName || 'Unknown',
            userAvatar: user?.avatarUrl || null,
          };
        })
      );
      
      res.json(registrationsWithUsers);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/registrations/:id", async (req, res) => {
    try {
      const registration = await storage.getRegistration(req.params.id);
      if (!registration) {
        return res.status(404).json({ error: "Registration not found" });
      }

      const responses = await storage.getResponsesByRegistration(registration.id);
      const user = await storage.getUser(registration.userId);
      
      res.json({ 
        ...registration, 
        responses,
        userUsername: user?.username || user?.displayName || 'Unknown',
        userDisplayName: user?.displayName || 'Unknown',
        userAvatar: user?.avatarUrl || null,
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/registrations/:id", async (req, res) => {
    try {
      const registration = await storage.updateRegistration(req.params.id, req.body);
      if (!registration) {
        return res.status(404).json({ error: "Registration not found" });
      }

      if (req.body.paymentStatus === "verified" && registration.status === "submitted") {
        const team = await storage.createTeam({
          name: registration.teamName,
          tournamentId: registration.tournamentId,
        });
        // Add registering user as team member
        await storage.createTeamMember({
          teamId: team.id,
          userId: registration.userId,
        });

        await storage.updateRegistration(registration.id, { status: "approved" });

        // Auto-generate fixtures when a team registers
        try {
          const tournament = await storage.getTournament(registration.tournamentId);
          if (tournament) {
            const allTeams = await storage.getTeamsByTournament(tournament.id);
            const existingMatches = await storage.getMatchesByTournament(tournament.id);
            
            // Only generate if no matches exist yet
            if (existingMatches.length === 0 && allTeams.length > 0) {
              let matches;
              if (tournament.format === "round_robin") {
                matches = generateRoundRobinBracket(tournament.id, allTeams).matches;
              } else if (tournament.format === "single_elimination") {
                matches = generateSingleEliminationBracket(tournament.id, allTeams).matches;
              } else if (tournament.format === "swiss") {
                matches = generateSwissSystemRound(tournament.id, allTeams, 1, []).matches;
              }

              if (matches && matches.length > 0) {
                // Create all matches
                await Promise.all(matches.map((match) => storage.createMatch(match)));
                
                // Create message threads for each match
                for (const match of matches) {
                  const team1 = allTeams.find(t => t.id === match.team1Id);
                  const team2 = allTeams.find(t => t.id === match.team2Id);
                  
                  // Skip bye matches
                  if (!team1 || !team2) continue;
                  
                  const threadName = `${team1.name} vs ${team2.name}`;
                  await storage.createMessageThread({
                    userId: tournament.organizerId || 'system',
                    participantName: threadName,
                    participantAvatar: null,
                    lastMessage: `Match created: ${threadName}`,
                    unreadCount: 0,
                  });
                }
              }
            }
          }
        } catch (error) {
          console.error("[FIXTURES] Error auto-generating fixtures:", error);
          // Don't fail registration if fixture generation fails
        }
      }

      res.json(registration);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Get all channels (for public discovery or user's channels)
  app.get("/api/channels", async (req, res) => {
    try {
      // If serverId is provided, get channels for that server
      const serverId = req.query.serverId as string;
      if (serverId) {
        const channels = await storage.getChannelsByServer(serverId);
        res.json(channels);
      } else {
        // Return empty array - channels require a serverId context
        res.json([]);
      }
    } catch (error: any) {
      console.error("Error fetching channels:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Get all servers (for user discovery or admin)
  app.get("/api/servers", async (req, res) => {
    try {
      // Return all public servers
      const allServers = await storage.getAllServers();
      res.json(allServers);
    } catch (error: any) {
      console.error("Error fetching servers:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // REST endpoint for sending channel messages (alternative to WebSocket)
  app.post("/api/channels/:channelId/messages", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const { message, imageUrl, replyToId } = req.body;
      const { channelId } = req.params;
      
      // Get user info for username
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }
      
      const validatedData = insertChannelMessageSchema.parse({
        channelId,
        userId: req.session.userId,
        username: user.username || user.displayName || 'Unknown',
        message: message?.trim() || '',
        imageUrl: imageUrl || null,
        replyToId: replyToId || null,
      });
      
      const savedMessage = await storage.createChannelMessage(validatedData);
      res.status(201).json(savedMessage);
    } catch (error: any) {
      console.error("Error creating channel message:", error);
      res.status(400).json({ error: error.message });
    }
  });

  // Mobile preview API routes
  app.get("/api/mobile-preview/servers", async (_req, res) => {
    try {
      const servers = await storage.getAllServers();
      res.json(servers);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/mobile-preview/messages", async (_req, res) => {
    try {
      const messages = await storage.getAllMessageThreads();
      res.json(messages);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/mobile-preview/notifications", async (_req, res) => {
    try {
      const notifications = await storage.getAllNotifications();
      res.json(notifications);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Server routes
  app.post("/api/servers", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      // Explicitly extract only allowed fields to prevent prototype pollution
      const allowedFields = {
        name: req.body.name,
        description: req.body.description,
        memberCount: req.body.memberCount,
        iconUrl: req.body.iconUrl,
        backgroundUrl: req.body.backgroundUrl,
        category: req.body.category,
        gameTags: req.body.gameTags,
        isPublic: req.body.isPublic,
      };
      
      const validatedData = insertServerSchema.omit({ ownerId: true }).parse(allowedFields);
      // Set ownerId from session, not from client
      const server = await storage.createServer({
        ...validatedData,
        ownerId: req.session.userId,
      });
      
      // Create default channels for the server
      const defaultChannels = [
        { name: "tournament-dashboard", slug: "tournament-dashboard", type: "tournament_dashboard", icon: "", serverId: server.id, position: 0, isPrivate: 1 },
        { name: "announcements", slug: "announcements", type: "announcements", icon: "", serverId: server.id, position: 1 },
        { name: "general", slug: "general", type: "chat", icon: "", serverId: server.id, position: 2 },
      ];
      
      for (const channelData of defaultChannels) {
        await storage.createChannel(channelData);
      }
      
      // Add the owner as a member of the server
      await storage.joinServer(server.id, req.session.userId);
      
      res.status(201).json(server);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:id", async (req, res) => {
    try {
      const server = await storage.getServer(req.params.id);
      if (!server) {
        return res.status(404).json({ error: "Server not found" });
      }
      res.json(server);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/servers/:serverId/join", async (req, res) => {
    try {
      const { userId } = req.body;
      if (!userId) {
        return res.status(400).json({ error: "userId is required" });
      }
      
      // Check if user is already in server
      const existingMember = await storage.getServerMember(req.params.serverId, userId);
      if (existingMember) {
        // Return success with alreadyMember flag - idempotent behavior
        return res.status(200).json({ 
          member: existingMember, 
          alreadyMember: true,
          serverId: req.params.serverId
        });
      }
      
      const member = await storage.joinServer(req.params.serverId, userId);
      res.status(201).json({ 
        member, 
        alreadyMember: false,
        serverId: req.params.serverId
      });
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/users/:userId/servers", async (req, res) => {
    try {
      const servers = await storage.getServersByUser(req.params.userId);
      res.json(servers);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Channel routes
  app.get("/api/servers/:serverId/channels", async (req, res) => {
    try {
      const channels = await storage.getChannelsByServer(req.params.serverId);
      res.json(channels);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/servers/:serverId/channels", async (req, res) => {
    try {
      const validatedData = insertChannelSchema.parse({
        ...req.body,
        serverId: req.params.serverId,
      });
      const channel = await storage.createChannel(validatedData);
      res.status(201).json(channel);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/channels/:id", async (req, res) => {
    try {
      const channel = await storage.getChannel(req.params.id);
      if (!channel) {
        return res.status(404).json({ error: "Channel not found" });
      }
      res.json(channel);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Poster template routes
  app.get("/api/poster-templates", async (req, res) => {
    try {
      const templates = req.query.active === "true"
        ? await storage.getActivePosterTemplates()
        : await storage.getAllPosterTemplates();
      res.json(templates);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/poster-templates/:id", async (req, res) => {
    try {
      const template = await storage.getPosterTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }
      res.json(template);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/poster-templates", async (req, res) => {
    try {
      const validatedData = insertPosterTemplateSchema.parse(req.body);
      const template = await storage.createPosterTemplate(validatedData);
      
      if (req.body.tags && Array.isArray(req.body.tags)) {
        for (const tag of req.body.tags) {
          await storage.createPosterTemplateTag({
            templateId: template.id,
            tag,
          });
        }
      }
      
      res.status(201).json(template);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.patch("/api/poster-templates/:id", async (req, res) => {
    try {
      const { tags, ...templateData } = req.body;
      
      const template = await storage.updatePosterTemplate(req.params.id, templateData);
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }
      
      if (tags && Array.isArray(tags)) {
        await storage.deleteTagsByTemplate(template.id);
        for (const tag of tags) {
          await storage.createPosterTemplateTag({
            templateId: template.id,
            tag,
          });
        }
      }
      
      res.json(template);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/poster-templates/:id", async (req, res) => {
    try {
      await storage.deletePosterTemplate(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/poster-templates/:id/tags", async (req, res) => {
    try {
      const tags = await storage.getTagsByTemplate(req.params.id);
      res.json(tags);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // User routes
  app.post("/api/users", async (req, res) => {
    try {
      const validatedData = insertUserSchema.parse(req.body);
      const user = await storage.createUser(validatedData);
      res.status(201).json(user);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/users/:id", async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/users/username/:username", async (req, res) => {
    try {
      const user = await storage.getUserByUsername(req.params.username);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/users/:id", async (req, res) => {
    try {
      const updateSchema = z.object({
        username: z.string().optional(),
        email: z.string().email().optional(),
        displayName: z.string().optional(),
        bio: z.string().optional(),
        avatarUrl: z.string().optional(),
        language: z.enum(["en", "es", "fr", "de", "ja"]).optional(),
        isDisabled: z.coerce.number().optional(),
      });
      const validatedData = updateSchema.parse(req.body);
      console.log('[PATCH-USER] Updating user:', req.params.id, 'with data:', JSON.stringify(validatedData));
      const user = await storage.updateUser(req.params.id, validatedData);
      console.log('[PATCH-USER] Update result:', JSON.stringify(user));
      if (!user) {
        console.log('[PATCH-USER] User not found:', req.params.id);
        return res.status(404).json({ error: "User not found" });
      }
      console.log('[PATCH-USER] Returning user:', JSON.stringify(user));
      res.json(user);
    } catch (error: any) {
      console.error('[PATCH-USER] Error:', error.message);
      res.status(400).json({ error: error.message });
    }
  });

  app.post("/api/users/:id/password", async (req, res) => {
    try {
      const passwordSchema = z.object({
        currentPassword: z.string(),
        newPassword: z.string().min(8),
      });
      const validatedData = passwordSchema.parse(req.body);
      
      const success = await storage.changeUserPassword(
        req.params.id,
        validatedData.currentPassword,
        validatedData.newPassword
      );
      
      if (!success) {
        return res.status(400).json({ error: "Current password is incorrect" });
      }
      
      res.json({ success: true });
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.post("/api/users/:id/disable", async (req, res) => {
    try {
      const user = await storage.updateUser(req.params.id, { isDisabled: 1 });
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/users/:id", async (req, res) => {
    try {
      await storage.deleteUser(req.params.id);
      res.json({ success: true });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Achievement routes
  app.post("/api/achievements", async (req, res) => {
    try {
      const validatedData = insertAchievementSchema.parse(req.body);
      const achievement = await storage.createAchievement(validatedData);
      res.status(201).json(achievement);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/users/:userId/achievements", async (req, res) => {
    try {
      const achievements = await storage.getAchievementsByUser(req.params.userId);
      res.json(achievements);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Get user roles - optionally filtered by server
  app.get("/api/users/:userId/roles", async (req, res) => {
    try {
      const serverId = req.query.serverId as string;
      if (serverId) {
        const roles = await storage.getRolesByUser(req.params.userId, serverId);
        res.json(roles);
      } else {
        // Return empty array if no serverId specified - roles are server-specific
        res.json([]);
      }
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Team profile routes
  app.post("/api/team-profiles", async (req, res) => {
    try {
      const validatedData = insertTeamProfileSchema.parse(req.body);
      const teamProfile = await storage.createTeamProfile(validatedData);
      res.status(201).json(teamProfile);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/team-profiles/:id", async (req, res) => {
    try {
      const teamProfile = await storage.getTeamProfile(req.params.id);
      if (!teamProfile) {
        return res.status(404).json({ error: "Team profile not found" });
      }
      res.json(teamProfile);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/users/:ownerId/team-profiles", async (req, res) => {
    try {
      const teamProfiles = await storage.getTeamProfilesByOwner(req.params.ownerId);
      res.json(teamProfiles);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/team-profiles/:id", async (req, res) => {
    try {
      const teamProfile = await storage.updateTeamProfile(req.params.id, req.body);
      if (!teamProfile) {
        return res.status(404).json({ error: "Team profile not found" });
      }
      res.json(teamProfile);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/team-profiles/:id", async (req, res) => {
    try {
      await storage.deleteTeamProfile(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Team member routes
  app.post("/api/team-profiles/:teamId/members", async (req, res) => {
    try {
      const validatedData = insertTeamMemberSchema.parse({
        ...req.body,
        teamId: req.params.teamId,
      });
      const member = await storage.createTeamMember(validatedData);
      res.status(201).json(member);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/team-profiles/:teamId/members", async (req, res) => {
    try {
      const members = await storage.getMembersByTeam(req.params.teamId);
      res.json(members);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/team-profiles/:teamId/members/:userId", async (req, res) => {
    try {
      await storage.deleteMemberFromTeam(req.params.teamId, req.params.userId);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Server member routes
  app.post("/api/servers/:serverId/members", async (req, res) => {
    try {
      const validatedData = insertServerMemberSchema.parse({
        ...req.body,
        serverId: req.params.serverId,
      });
      const member = await storage.createServerMember(validatedData);
      res.status(201).json(member);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/members", async (req, res) => {
    try {
      const members = await storage.getMembersByServer(req.params.serverId);
      res.json(members);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/members/:userId", async (req, res) => {
    try {
      const member = await storage.getServerMemberByUserId(req.params.serverId, req.params.userId);
      if (!member) {
        return res.status(404).json({ error: "Member not found" });
      }
      res.json(member);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/servers/:serverId/members/:userId", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const server = await storage.getServer(req.params.serverId);
      if (!server) {
        return res.status(404).json({ error: "Server not found" });
      }

      const isOwner = server.ownerId === req.session.userId;
      const requesterPermissions = await storage.getEffectivePermissions(
        req.params.serverId,
        req.session.userId
      );
      const canManageRoles = requesterPermissions.includes("manage_roles") || 
                            requesterPermissions.includes("manage_server");

      if (!isOwner && !canManageRoles) {
        return res.status(403).json({ error: "Forbidden: Only server owners or users with manage_roles permission can update member permissions" });
      }

      const updateSchema = z.object({
        roleId: z.string().optional(),
        customTitle: z.string().optional(),
        explicitPermissions: z.array(z.string()).optional(),
      });
      const validatedData = updateSchema.parse(req.body);
      const member = await storage.updateServerMember(
        req.params.serverId,
        req.params.userId,
        validatedData
      );
      if (!member) {
        return res.status(404).json({ error: "Member not found" });
      }
      res.json(member);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/members/:userId/permissions", async (req, res) => {
    try {
      const effectivePermissions = await storage.getEffectivePermissions(
        req.params.serverId,
        req.params.userId
      );
      res.json({ permissions: effectivePermissions });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/servers/:serverId/members/:userId", async (req, res) => {
    try {
      await storage.deleteMemberFromServer(req.params.serverId, req.params.userId);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Object Storage Routes - Reference: blueprint:javascript_object_storage
  // Serve uploaded objects (with ACL check)
  app.get("/objects/:objectPath(*)", async (req, res) => {
    const objectStorageService = new ObjectStorageService();
    try {
      const objectFile = await objectStorageService.getObjectEntityFile(
        req.path,
      );
      
      // Check ACL policy - only serve public files
      const canAccess = await objectStorageService.canAccessObjectEntity({
        objectFile,
        requestedPermission: ObjectPermission.READ,
      });
      
      if (!canAccess) {
        return res.sendStatus(403);
      }
      
      objectStorageService.downloadObject(objectFile, res);
    } catch (error) {
      console.error("Error checking object access:", error);
      if (error instanceof ObjectNotFoundError) {
        return res.sendStatus(404);
      }
      return res.sendStatus(500);
    }
  });

  // File upload endpoint - saves to disk using multer
  app.post("/api/objects/upload", requireAuth, upload.single("file"), async (req, res) => {
    try {
      const file = req.file as Express.Multer.File | undefined;
      if (!file) {
        return res.status(400).json({ error: "No file provided" });
      }

      // Extract just the filename without extension
      const filename = path.basename(file.filename, path.extname(file.filename));
      
      // Return a URL to retrieve the file
      const fileUrl = `/api/uploads/${filename}`;
      res.json({ url: fileUrl, fileUrl });
    } catch (error: any) {
      console.error("Error uploading file:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Retrieve uploaded files from disk
  app.get("/api/uploads/:fileId", (req, res) => {
    try {
      // Search for file with any extension
      const files = fs.readdirSync(uploadsDir);
      const uploadedFile = files.find(f => path.basename(f, path.extname(f)) === req.params.fileId);
      
      if (!uploadedFile) {
        return res.status(404).json({ error: "File not found" });
      }

      const filePath = path.join(uploadsDir, uploadedFile);
      
      // Detect content type from file magic numbers
      let contentType = "application/octet-stream";
      const buffer = fs.readFileSync(filePath);
      if (buffer.length > 4) {
        const magic = buffer.slice(0, 4).toString("hex");
        if (magic.startsWith("ffd8ff")) contentType = "image/jpeg";
        else if (magic.startsWith("89504e47")) contentType = "image/png";
        else if (magic.startsWith("47494638")) contentType = "image/gif";
        else if (magic.startsWith("52494646") && buffer.length > 12) contentType = "image/webp";
      }

      res.set("Content-Type", contentType);
      res.sendFile(filePath);
    } catch (error: any) {
      console.error("Error retrieving file:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Generic endpoint to normalize uploaded object path and set ACL policy
  app.post("/api/objects/normalize", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    if (!req.body.objectPath) {
      return res.status(400).json({ error: "objectPath is required" });
    }

    // Validate that the object path starts with /objects/uploads/ 
    // to prevent users from changing ACLs on arbitrary objects
    if (!req.body.objectPath.startsWith("/objects/uploads/")) {
      return res.status(403).json({ error: "Invalid object path" });
    }

    try {
      const objectStorageService = new ObjectStorageService();
      // Set ACL policy for public access (most uploads are public)
      const normalizedPath = await objectStorageService.trySetObjectEntityAclPolicy(
        req.body.objectPath,
        {
          owner: req.session.userId,
          visibility: "public",
        },
      );

      res.status(200).json({
        objectPath: normalizedPath,
      });
    } catch (error: any) {
      console.error("Error normalizing uploaded object:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Normalize tournament poster path after upload and set ACL policy
  app.put("/api/tournament-posters", async (req, res) => {
    if (!req.body.posterURL) {
      return res.status(400).json({ error: "posterURL is required" });
    }

    try {
      const objectStorageService = new ObjectStorageService();
      // Set ACL policy for public access (tournament posters are public)
      const objectPath = await objectStorageService.trySetObjectEntityAclPolicy(
        req.body.posterURL,
        {
          owner: "system",
          visibility: "public",
        },
      );

      res.status(200).json({
        objectPath: objectPath,
      });
    } catch (error: any) {
      console.error("Error setting tournament poster:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Normalize avatar path after upload and set ACL policy
  app.put("/api/avatars", async (req, res) => {
    if (!req.body.avatarURL) {
      return res.status(400).json({ error: "avatarURL is required" });
    }

    try {
      const objectStorageService = new ObjectStorageService();
      const objectPath = await objectStorageService.trySetObjectEntityAclPolicy(
        req.body.avatarURL,
        {
          owner: req.body.userId || "system",
          visibility: "public",
        },
      );

      res.status(200).json({
        objectPath: objectPath,
      });
    } catch (error: any) {
      console.error("Error setting avatar:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Channel category routes
  app.post("/api/servers/:serverId/categories", async (req, res) => {
    try {
      const validatedData = insertChannelCategorySchema.parse({
        serverId: req.params.serverId,
        name: req.body.name,
        position: req.body.position,
      });
      const category = await storage.createChannelCategory(validatedData);
      res.status(201).json(category);
    } catch (error: any) {
      console.error("Error creating category:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/categories", async (req, res) => {
    try {
      const categories = await storage.getCategoriesByServer(req.params.serverId);
      res.status(200).json(categories);
    } catch (error: any) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/categories/:id", async (req, res) => {
    try {
      const updateSchema = z.object({
        name: z.string().optional(),
        position: z.number().optional(),
      });
      const validatedData = updateSchema.parse(req.body);
      const category = await storage.updateChannelCategory(req.params.id, validatedData);
      if (!category) {
        return res.status(404).json({ error: "Category not found" });
      }
      res.status(200).json(category);
    } catch (error: any) {
      console.error("Error updating category:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.delete("/api/categories/:id", async (req, res) => {
    try {
      await storage.deleteChannelCategory(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting category:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Channel update/delete routes
  app.patch("/api/channels/:id", async (req, res) => {
    try {
      const updateSchema = z.object({
        name: z.string().optional(),
        categoryId: z.string().nullable().optional(),
        position: z.number().optional(),
        icon: z.string().optional(),
      });
      const validatedData = updateSchema.parse(req.body);
      const channel = await storage.updateChannel(req.params.id, validatedData);
      if (!channel) {
        return res.status(404).json({ error: "Channel not found" });
      }
      res.status(200).json(channel);
    } catch (error: any) {
      console.error("Error updating channel:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.delete("/api/channels/:id", async (req, res) => {
    try {
      await storage.deleteChannel(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting channel:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Channel message routes
  app.get("/api/channels/:channelId/messages", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 100;
      const messages = await storage.getChannelMessages(req.params.channelId, limit);
      
      // Enrich messages with avatarUrl from users
      const enrichedMessages = await Promise.all(
        messages.map(async (msg: any) => {
          if (msg.userId) {
            const user = await storage.getUser(msg.userId);
            if (user?.avatarUrl) {
              return { ...msg, avatarUrl: user.avatarUrl };
            }
          }
          return msg;
        })
      );
      
      res.status(200).json(enrichedMessages);
    } catch (error: any) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/channels/:channelId/messages/search", async (req, res) => {
    try {
      const query = req.query.q as string;
      if (!query) {
        return res.status(400).json({ error: "Search query required" });
      }
      const messages = await storage.searchChannelMessages(req.params.channelId, query);
      res.status(200).json(messages);
    } catch (error: any) {
      console.error("Error searching messages:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/messages/:id", async (req, res) => {
    try {
      const updatedMessage = await storage.updateChannelMessage(req.params.id, { message: req.body.message });
      res.json(updatedMessage);
    } catch (error: any) {
      console.error("Error updating message:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/messages/:id", async (req, res) => {
    try {
      await storage.deleteChannelMessage(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting message:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Message threads routes (Direct messages / Group chats)
  app.get("/api/message-threads", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const currentUserId = req.session.userId;
      
      // Get both direct message threads AND match threads for user's teams
      const threads = await storage.getMessageThreadsForParticipant(currentUserId);
      
      // Batch fetch all unique user IDs (senders, creators, participants) to avoid N+1 queries
      const allUserIds = new Set<string>();
      threads.forEach(t => {
        if (t.lastMessageSenderId) allUserIds.add(t.lastMessageSenderId);
        if (t.userId) allUserIds.add(t.userId);
        if (t.participantId) allUserIds.add(t.participantId);
      });
      
      const userMap = new Map<string, { displayName?: string | null; username?: string | null; avatarUrl?: string | null }>();
      
      if (allUserIds.size > 0) {
        const users = await Promise.all(Array.from(allUserIds).map(id => storage.getUser(id)));
        const idsArray = Array.from(allUserIds);
        users.forEach((user, idx) => {
          if (user) {
            userMap.set(idsArray[idx], { 
              displayName: user.displayName, 
              username: user.username,
              avatarUrl: user.avatarUrl 
            });
          }
        });
      }
      
      // Enrich threads with correct display info based on viewer
      const enrichedThreads = threads.map(thread => {
        let lastMessageSenderName = null;
        if (thread.lastMessageSenderId) {
          const sender = userMap.get(thread.lastMessageSenderId);
          lastMessageSenderName = sender?.displayName || sender?.username || null;
        }
        
        // Determine the "other person" to display based on who is viewing
        // If current user is the creator (userId), show participant info
        // If current user is the participant, show creator info
        let displayName = thread.participantName;
        let displayAvatar = thread.participantAvatar;
        
        if (thread.userId && thread.participantId) {
          if (currentUserId === thread.participantId) {
            // Current user is the recipient, show the creator's info
            const creator = userMap.get(thread.userId);
            if (creator) {
              displayName = creator.displayName || creator.username || thread.participantName;
              displayAvatar = creator.avatarUrl || thread.participantAvatar;
            }
          }
          // If current user is the creator, participantName/Avatar is already correct
        }
        
        return {
          ...thread,
          lastMessageSenderName,
          participantName: displayName,
          participantAvatar: displayAvatar,
        };
      });
      
      res.json(enrichedThreads);
    } catch (error: any) {
      console.error("Error fetching message threads:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/message-threads", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const { participantId, participantName, participantAvatar, lastMessage } = req.body;
      
      // Check if a thread already exists between these two users
      if (participantId) {
        const existingThread = await storage.findExistingThread(req.session.userId, participantId);
        if (existingThread) {
          // Enrich with sender name before returning
          let lastMessageSenderName = null;
          if (existingThread.lastMessageSenderId) {
            const sender = await storage.getUser(existingThread.lastMessageSenderId);
            lastMessageSenderName = sender?.displayName || sender?.username || null;
          }
          return res.status(200).json({ ...existingThread, lastMessageSenderName });
        }
      }
      
      const validatedData = insertMessageThreadSchema.parse({
        userId: req.session.userId,
        participantId: participantId || null,
        participantName: participantName,
        participantAvatar: participantAvatar || null,
        lastMessage: lastMessage || "",
        unreadCount: 0,
      });
      
      const thread = await storage.createMessageThread(validatedData);
      res.status(201).json({ ...thread, lastMessageSenderName: null });
    } catch (error: any) {
      console.error("Error creating message thread:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/message-threads/:id", async (req, res) => {
    try {
      const thread = await storage.getMessageThread(req.params.id);
      if (!thread) {
        return res.status(404).json({ error: "Thread not found" });
      }
      res.json(thread);
    } catch (error: any) {
      console.error("Error fetching message thread:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/message-threads/:id/messages", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }
      
      const validatedData = insertThreadMessageSchema.parse({
        threadId: req.params.id,
        userId: req.session.userId,
        username: user.username,
        message: req.body.message,
      });
      
      const message = await storage.createThreadMessage(validatedData);
      
      // Update thread's lastMessage and lastMessageSenderId
      await storage.updateMessageThread(req.params.id, {
        lastMessage: req.body.message,
        lastMessageSenderId: req.session.userId,
        lastMessageTime: new Date(),
      });
      
      res.status(201).json(message);
    } catch (error: any) {
      console.error("Error creating thread message:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/message-threads/:id/messages", async (req, res) => {
    try {
      const messages = await storage.getThreadMessages(req.params.id);
      // Enrich messages with sender avatarUrl and displayName from users table
      const enrichedMessages: any[] = await Promise.all(
        messages.map(async (msg) => {
          if (msg.userId) {
            const sender = await storage.getUser(msg.userId);
            const displayName = sender?.displayName?.trim() || sender?.username || msg.username;
            return {
              ...msg,
              avatarUrl: sender?.avatarUrl || undefined,
              displayName: displayName,
              username: msg.username,
            };
          }
          return msg;
        })
      );
      console.log("[THREAD-MSG-ENRICHMENT] Enriched messages:", JSON.stringify(enrichedMessages.slice(0, 2), null, 2));
      res.json(enrichedMessages);
    } catch (error: any) {
      console.error("Error fetching thread messages:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Get or create message thread for a match (for tournament match chat)
  app.get("/api/matches/:matchId/thread", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const { matchId } = req.params;
      
      // Try to find existing thread for this match using storage
      const threads = await storage.getMessageThreads();
      const existingThread = threads.find(t => t.matchId === matchId);
      
      if (existingThread) {
        return res.json(existingThread);
      }
      
      // Create new match thread if it doesn't exist
      const newThread = await storage.createMessageThread({
        matchId: matchId,
        participantName: `Match Discussion`,
        participantAvatar: null,
        lastMessage: "Match discussion started",
        unreadCount: 0,
      });
      
      res.json(newThread);
    } catch (error: any) {
      console.error("Error getting/creating match thread:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/message-threads/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const updateSchema = z.object({
        participantName: z.string().optional(),
        participantAvatar: z.string().optional(),
        lastMessage: z.string().optional(),
        unreadCount: z.number().optional(),
      });
      
      const validatedData = updateSchema.parse(req.body);
      const thread = await storage.updateMessageThread(req.params.id, validatedData);
      
      if (!thread) {
        return res.status(404).json({ error: "Thread not found" });
      }
      
      res.json(thread);
    } catch (error: any) {
      console.error("Error updating message thread:", error);
      res.status(400).json({ error: error.message });
    }
  });

  // Server role routes
  app.post("/api/servers/:serverId/roles", async (req, res) => {
    try {
      const validatedData = insertServerRoleSchema.parse({
        serverId: req.params.serverId,
        name: req.body.name,
        color: req.body.color,
        permissions: req.body.permissions,
        position: req.body.position,
      });
      const role = await storage.createServerRole(validatedData);
      res.status(201).json(role);
    } catch (error: any) {
      console.error("Error creating role:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/roles", async (req, res) => {
    try {
      const roles = await storage.getRolesByServer(req.params.serverId);
      res.status(200).json(roles);
    } catch (error: any) {
      console.error("Error fetching roles:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.patch("/api/roles/:id", async (req, res) => {
    try {
      const updateSchema = z.object({
        name: z.string().optional(),
        color: z.string().optional(),
        permissions: z.array(z.string()).optional(),
        position: z.number().optional(),
      });
      const validatedData = updateSchema.parse(req.body);
      const role = await storage.updateServerRole(req.params.id, validatedData);
      if (!role) {
        return res.status(404).json({ error: "Role not found" });
      }
      res.status(200).json(role);
    } catch (error: any) {
      console.error("Error updating role:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.delete("/api/roles/:id", async (req, res) => {
    try {
      await storage.deleteServerRole(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting role:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Server ban routes
  app.post("/api/servers/:serverId/bans", async (req, res) => {
    try {
      const validatedData = insertServerBanSchema.parse({
        serverId: req.params.serverId,
        userId: req.body.userId,
        reason: req.body.reason,
        bannedBy: req.body.bannedBy,
      });
      const ban = await storage.createServerBan(validatedData);
      res.status(201).json(ban);
    } catch (error: any) {
      console.error("Error creating ban:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/bans", async (req, res) => {
    try {
      const bans = await storage.getBansByServer(req.params.serverId);
      res.status(200).json(bans);
    } catch (error: any) {
      console.error("Error fetching bans:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/servers/:serverId/bans/:userId", async (req, res) => {
    try {
      await storage.deleteBan(req.params.serverId, req.params.userId);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting ban:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Server invite routes
  app.post("/api/servers/:serverId/invites", async (req, res) => {
    try {
      const code = Math.random().toString(36).substring(2, 10);
      const validatedData = insertServerInviteSchema.parse({
        serverId: req.params.serverId,
        code,
        createdBy: req.body.createdBy,
        expiresAt: req.body.expiresAt,
        maxUses: req.body.maxUses,
      });
      const invite = await storage.createServerInvite(validatedData);
      res.status(201).json(invite);
    } catch (error: any) {
      console.error("Error creating invite:", error);
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/servers/:serverId/invites", async (req, res) => {
    try {
      const invites = await storage.getInvitesByServer(req.params.serverId);
      res.status(200).json(invites);
    } catch (error: any) {
      console.error("Error fetching invites:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.get("/api/invites/:code", async (req, res) => {
    try {
      const invite = await storage.getInviteByCode(req.params.code);
      if (!invite) {
        return res.status(404).json({ error: "Invite not found" });
      }
      res.status(200).json(invite);
    } catch (error: any) {
      console.error("Error fetching invite:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.post("/api/invites/:code/use", async (req, res) => {
    try {
      const invite = await storage.getInviteByCode(req.params.code);
      if (!invite) {
        return res.status(404).json({ error: "Invite not found" });
      }
      
      if (invite.maxUses && (invite.currentUses || 0) >= invite.maxUses) {
        return res.status(400).json({ error: "Invite has reached maximum uses" });
      }
      
      if (invite.expiresAt && new Date(invite.expiresAt) < new Date()) {
        return res.status(400).json({ error: "Invite has expired" });
      }

      await storage.incrementInviteUse(req.params.code);
      await storage.joinServer(invite.serverId, req.body.userId);
      res.status(200).json({ success: true, serverId: invite.serverId });
    } catch (error: any) {
      console.error("Error using invite:", error);
      res.status(500).json({ error: error.message });
    }
  });

  app.delete("/api/invites/:id", async (req, res) => {
    try {
      await storage.deleteInvite(req.params.id);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting invite:", error);
      res.status(500).json({ error: error.message });
    }
  });

  // Server update route
  app.patch("/api/servers/:id", async (req, res) => {
    try {
      const updateSchema = z.object({
        name: z.string().optional(),
        description: z.string().optional(),
        iconUrl: z.string().optional(),
        backgroundUrl: z.string().optional(),
        category: z.string().optional(),
        gameTags: z.array(z.string()).optional(),
        isPublic: z.number().optional(),
      });
      const validatedData = updateSchema.parse(req.body);
      const server = await storage.updateServer(req.params.id, validatedData);
      if (!server) {
        return res.status(404).json({ error: "Server not found" });
      }
      res.status(200).json(server);
    } catch (error: any) {
      console.error("Error updating server:", error);
      res.status(400).json({ error: error.message });
    }
  });

  // =============== ADMIN PANEL ROUTES ===============

  // Admin - Get all users
  app.get("/api/admin/users", async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      res.json(allUsers);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Get all organizers with permissions
  app.get("/api/admin/organizers", async (req, res) => {
    try {
      const organizers = await storage.getOrganizerUsers();
      const withPermissions = await Promise.all(
        organizers.map(async (org) => ({
          ...org,
          canGiveAchievements: await storage.getOrganizerPermission(org.id),
        }))
      );
      res.json(withPermissions);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Change user role
  app.patch("/api/admin/users/:userId/role", async (req, res) => {
    try {
      const { role } = req.body;
      if (!["player", "organizer", "admin"].includes(role)) {
        return res.status(400).json({ error: "Invalid role" });
      }
      const user = await storage.updateUser(req.params.userId, { role });
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Ban/Unban user
  app.patch("/api/admin/users/:userId/ban", async (req, res) => {
    try {
      const { isBanned } = req.body;
      const user = await storage.updateUser(req.params.userId, { isBanned });
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Delete user
  app.delete("/api/admin/users/:userId", async (req, res) => {
    try {
      await storage.deleteUser(req.params.userId);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Get all achievements
  app.get("/api/admin/achievements", async (req, res) => {
    try {
      const allAchievements = await storage.getAllAchievements();
      const withUsernames = await Promise.all(
        allAchievements.map(async (ach) => {
          const user = await storage.getUser(ach.userId);
          return { ...ach, username: user?.username };
        })
      );
      res.json(withUsernames);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Give achievement
  app.post("/api/admin/achievements", async (req, res) => {
    try {
      const { userId, title, description, type } = req.body;
      const achievement = await storage.createAchievement({
        userId,
        title,
        description,
        type,
        awardedBy: req.session?.userId || "admin",
      });
      res.status(201).json(achievement);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  // Admin - Delete achievement
  app.delete("/api/admin/achievements/:achievementId", async (req, res) => {
    try {
      await storage.deleteAchievement(req.params.achievementId);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Toggle organizer permissions
  app.patch("/api/admin/organizers/:organizerId/permissions", async (req, res) => {
    try {
      const { canGiveAchievements } = req.body;
      const perm = await storage.updateOrganizerPermission(
        req.params.organizerId,
        { canGiveAchievements }
      );
      res.json(perm);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Get all tournaments
  app.get("/api/admin/tournaments", async (req, res) => {
    try {
      const tournaments = await storage.getAllTournaments();
      res.json(tournaments);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Delete tournament
  app.delete("/api/admin/tournaments/:tournamentId", async (req, res) => {
    try {
      await storage.deleteTournament(req.params.tournamentId);
      res.status(204).send();
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Freeze/unfreeze tournament
  app.patch("/api/admin/tournaments/:tournamentId", async (req, res) => {
    try {
      const { isFrozen } = req.body;
      const tournament = await storage.updateTournament(
        req.params.tournamentId,
        { isFrozen }
      );
      res.json(tournament);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Get reports
  app.get("/api/admin/reports", async (req, res) => {
    try {
      const reports = await storage.getAllReports();
      res.json(reports);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Resolve/dismiss report
  app.patch("/api/admin/reports/:reportId", async (req, res) => {
    try {
      const { status } = req.body;
      const report = await storage.updateReport(req.params.reportId, {
        status,
        resolvedBy: req.session?.userId,
        resolvedAt: new Date(),
      });
      res.json(report);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Get customer service messages
  app.get("/api/admin/customer-service-messages", async (req, res) => {
    try {
      const messages = await storage.getAllCustomerServiceMessages();
      res.json(messages);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Admin - Respond to customer service message
  app.patch("/api/admin/customer-service-messages/:messageId", async (req, res) => {
    try {
      const { response, status } = req.body;
      const message = await storage.updateCustomerServiceMessage(
        req.params.messageId,
        {
          response,
          status,
          respondedBy: req.session?.userId,
          respondedAt: new Date(),
        }
      );
      res.json(message);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Send friend request
  app.post("/api/friend-request", async (req, res) => {
    try {
      if (!req.session?.userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }

      const { recipientId } = req.body;
      if (!recipientId) {
        return res.status(400).json({ error: "Recipient ID required" });
      }

      if (recipientId === req.session.userId) {
        return res.status(400).json({ error: "Cannot send friend request to yourself" });
      }

      // Validate that recipientId is a valid UUID format
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(recipientId)) {
        return res.status(400).json({ error: "Invalid recipient ID format" });
      }

      // Verify recipient exists
      const recipient = await storage.getUser(recipientId);
      if (!recipient) {
        return res.status(404).json({ error: "User not found" });
      }

      // Check if friend request already exists between users
      const existingRequest = await storage.getFriendRequestBetweenUsers(req.session.userId, recipientId);
      if (existingRequest) {
        return res.json({ 
          success: true, 
          friendRequest: existingRequest,
          message: existingRequest.status === "pending" ? "Request already sent" : `Request already ${existingRequest.status}`
        });
      }

      // Create friend request record
      const friendRequest = await storage.createFriendRequest({
        senderId: req.session.userId,
        recipientId: recipientId,
        status: "pending",
      });

      // Create notification for friend request
      const sender = await storage.getUser(req.session.userId);
      const notification = await storage.createNotification({
        userId: recipientId,
        senderId: req.session.userId,
        type: "friend_request",
        title: `Friend request`,
        message: `${sender?.displayName || sender?.username || 'Someone'} sent you a friend request`,
        read: 0,
      });

      res.json({ success: true, friendRequest, notification });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Get friend request status between current user and another user
  app.get("/api/friend-requests/status/:userId", async (req, res) => {
    try {
      if (!req.session?.userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }

      const { userId } = req.params;
      const request = await storage.getFriendRequestBetweenUsers(req.session.userId, userId);
      
      if (!request) {
        return res.json({ status: "none" });
      }

      res.json({
        status: request.status,
        isSender: request.senderId === req.session.userId,
        friendRequest: request,
      });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Get pending friend requests for current user
  app.get("/api/friend-requests/pending", async (req, res) => {
    try {
      if (!req.session?.userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }

      const requests = await storage.getPendingFriendRequests(req.session.userId);
      
      // Enrich with sender info
      const enrichedRequests = await Promise.all(
        requests.map(async (request) => {
          const sender = await storage.getUser(request.senderId);
          return {
            ...request,
            senderName: sender?.displayName || sender?.username || "Unknown",
            senderAvatar: sender?.avatarUrl,
          };
        })
      );

      res.json(enrichedRequests);
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Accept friend request
  app.post("/api/friend-requests/:id/accept", async (req, res) => {
    try {
      if (!req.session?.userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }

      const request = await storage.updateFriendRequest(req.params.id, {
        status: "accepted",
        respondedAt: new Date(),
      });

      if (!request) {
        return res.status(404).json({ error: "Friend request not found" });
      }

      res.json({ success: true, friendRequest: request });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  // Decline friend request
  app.post("/api/friend-requests/:id/decline", async (req, res) => {
    try {
      if (!req.session?.userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }

      const request = await storage.updateFriendRequest(req.params.id, {
        status: "declined",
        respondedAt: new Date(),
      });

      if (!request) {
        return res.status(404).json({ error: "Friend request not found" });
      }

      res.json({ success: true, friendRequest: request });
    } catch (error: any) {
      res.status(500).json({ error: error.message });
    }
  });

  return httpServer;
}
